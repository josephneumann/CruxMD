/**
 * Application-level TypeScript types for CruxMD frontend.
 *
 * API types are auto-generated by @hey-api/openapi-ts in lib/generated/.
 * This file contains app-specific types and chat/agent types that mirror
 * the backend Pydantic schemas.
 */

import type { FhirPatient } from "./utils";

// Re-export generated types for convenience
export type { BundleLoadResponse } from "./generated";

// =============================================================================
// Chat API Types (mirrors backend/app/routes/chat.py)
// =============================================================================

/** Input validation constants matching backend limits */
export const MAX_MESSAGE_LENGTH = 10000;
export const MAX_CONVERSATION_HISTORY = 50;

/** Valid message roles - source of truth for type and validation */
export const MESSAGE_ROLES = ["user", "assistant"] as const;
export type MessageRole = (typeof MESSAGE_ROLES)[number];

/** A single message in conversation history */
export interface ChatMessage {
  role: MessageRole;
  content: string;
}

/** Available model options for the chat */
export const MODEL_OPTIONS = [
  { id: "gpt-5", label: "GPT-5", description: "Intelligent reasoning model" },
  { id: "gpt-5-mini", label: "GPT-5 mini", description: "Fast and cost-efficient" },
  { id: "gpt-5-nano", label: "GPT-5 nano", description: "Lightweight and instant" },
] as const;

export type ModelId = (typeof MODEL_OPTIONS)[number]["id"];

export const DEFAULT_MODEL: ModelId = "gpt-5-mini";

/** Request body for POST /api/chat */
export interface ChatRequest {
  patient_id: string;
  message: string;
  conversation_id?: string;
  session_id?: string;
  conversation_history?: ChatMessage[];
  model?: string;
  reasoning_boost?: boolean;
}

/** Response wrapper from POST /api/chat */
export interface ChatResponse {
  conversation_id: string;
  response: AgentResponse;
}

// =============================================================================
// Agent Response Types (mirrors backend/app/schemas/agent.py)
// =============================================================================

/** Valid insight types - source of truth for type and validation */
export const INSIGHT_TYPES = ["info", "warning", "critical", "positive"] as const;
export type InsightType = (typeof INSIGHT_TYPES)[number];

/** Clinical insight highlighted for the user */
export interface Insight {
  type: InsightType;
  title: string;
  content: string;
  citations?: string[];
}

/** Clinical table types matching backend ClinicalTable.type */
export const CLINICAL_TABLE_TYPES = [
  "medications", "lab_results", "vitals", "conditions",
  "allergies", "immunizations", "procedures", "encounters",
] as const;
export type ClinicalTableType = (typeof CLINICAL_TABLE_TYPES)[number];

/** Resource-typed clinical data table with inline data */
export interface ClinicalTable {
  type: ClinicalTableType;
  title: string;
  /** Array of row objects (deterministically generated by backend) */
  rows: Record<string, unknown>[];
}

/** HL7 FHIR Observation Interpretation codes */
export type HL7Interpretation = "N" | "H" | "L" | "HH" | "LL";

/** History data point for sparklines */
export interface HistoryPoint {
  value: number;
  date: string;
}

/** Single data point on a trend chart */
export interface TrendPoint {
  date: string;
  value: number;
  label?: string;
}

/** One line/area on a trend chart */
export interface TrendSeries {
  name: string;
  unit?: string;
  data_points: TrendPoint[];
}

/** Horizontal threshold line */
export interface ReferenceLine {
  value: number;
  label: string;
}

/** Background color zone for clinical ranges */
export interface RangeBand {
  y1: number;
  y2: number;
  severity: "normal" | "warning" | "critical";
  label?: string;
}

/** One segment in a medication timeline bar */
export interface MedTimelineSegment {
  label: string;
  flex: number;
  active: boolean;
}

/** One drug row in the medication timeline */
export interface MedTimelineRow {
  drug: string;
  segments: MedTimelineSegment[];
}

/** Single event on an encounter timeline */
export interface TimelineEvent {
  date: string;
  title: string;
  detail?: string;
  category?: string;
}

/** Clinical visualization types */
export const CLINICAL_VIZ_TYPES = ["trend_chart", "encounter_timeline"] as const;
export type ClinicalVisualizationType = (typeof CLINICAL_VIZ_TYPES)[number];

/** Clinical chart or timeline with inline data */
export interface ClinicalVisualization {
  type: ClinicalVisualizationType;
  title: string;
  subtitle?: string;
  current_value?: string;
  trend_summary?: string;
  trend_status?: "positive" | "warning" | "critical" | "neutral";
  // trend_chart fields
  series?: TrendSeries[];
  reference_lines?: ReferenceLine[];
  range_bands?: RangeBand[];
  medications?: MedTimelineRow[];
  // encounter_timeline fields
  events?: TimelineEvent[];
}

/** Suggested follow-up question for emergent navigation */
export interface FollowUp {
  question: string;
  intent?: string;
}

/** Structured response from the clinical reasoning agent */
export interface AgentResponse {
  thinking?: string;
  narrative: string;
  insights?: Insight[];
  tables?: ClinicalTable[];
  visualizations?: ClinicalVisualization[];
  follow_ups?: FollowUp[];
}

// =============================================================================
// SSE Stream Event Types (mirrors backend POST /api/chat/stream)
// =============================================================================

/** Reasoning text delta streamed during generation */
export interface StreamDeltaEvent {
  delta: string;
}

/** Final response when stream completes */
export interface StreamDoneEvent {
  conversation_id: string;
  response: AgentResponse;
}

/** Error during streaming */
export interface StreamErrorEvent {
  detail: string;
}

/** Known agent tool names (mirrors backend TOOL_SCHEMAS) */
export const TOOL_NAMES = {
  QUERY_PATIENT_DATA: "query_patient_data",
  EXPLORE_CONNECTIONS: "explore_connections",
  GET_PATIENT_TIMELINE: "get_patient_timeline",
} as const;

export type ToolName = (typeof TOOL_NAMES)[keyof typeof TOOL_NAMES];

/** Tool call event — LLM is invoking a tool */
export interface StreamToolCallEvent {
  name: string;
  call_id: string;
  arguments: string;
}

/** Tool result event — tool execution completed */
export interface StreamToolResultEvent {
  call_id: string;
  name: string;
  output: string;
}

// =============================================================================
// Type Guards for Runtime Validation
// =============================================================================

/** Helper to check if value is a non-null object */
function isObject(obj: unknown): obj is Record<string, unknown> {
  return typeof obj === "object" && obj !== null;
}

/** Type guard for ChatMessage */
export function isChatMessage(obj: unknown): obj is ChatMessage {
  if (!isObject(obj)) return false;
  return (
    MESSAGE_ROLES.includes(obj.role as MessageRole) &&
    typeof obj.content === "string"
  );
}

/** Type guard for Insight */
export function isInsight(obj: unknown): obj is Insight {
  if (!isObject(obj)) return false;
  if (!INSIGHT_TYPES.includes(obj.type as InsightType)) return false;
  if (typeof obj.title !== "string") return false;
  if (typeof obj.content !== "string") return false;
  // Validate citations array if present
  if (obj.citations != null) {
    if (!Array.isArray(obj.citations)) return false;
    if (!obj.citations.every((c) => typeof c === "string")) return false;
  }
  return true;
}

/** Type guard for ClinicalTable */
export function isClinicalTable(obj: unknown): obj is ClinicalTable {
  if (!isObject(obj)) return false;
  if (!CLINICAL_TABLE_TYPES.includes(obj.type as ClinicalTableType)) return false;
  if (typeof obj.title !== "string") return false;
  if (!Array.isArray(obj.rows)) return false;
  return true;
}

/** Type guard for ClinicalVisualization */
export function isClinicalVisualization(obj: unknown): obj is ClinicalVisualization {
  if (!isObject(obj)) return false;
  if (!CLINICAL_VIZ_TYPES.includes(obj.type as ClinicalVisualizationType)) return false;
  if (typeof obj.title !== "string") return false;
  return true;
}

/** Type guard for FollowUp */
export function isFollowUp(obj: unknown): obj is FollowUp {
  if (!isObject(obj)) return false;
  if (typeof obj.question !== "string") return false;
  if (obj.intent != null && typeof obj.intent !== "string") return false;
  return true;
}

/** Type guard for AgentResponse with deep validation */
export function isAgentResponse(obj: unknown): obj is AgentResponse {
  if (!isObject(obj)) return false;
  // narrative is the only required field
  if (typeof obj.narrative !== "string") return false;
  if (obj.thinking != null && typeof obj.thinking !== "string") return false;
  // Validate optional arrays with element-level validation
  // Backend sends null for absent optional fields (Python None → JSON null)
  if (obj.insights != null) {
    if (!Array.isArray(obj.insights)) return false;
    if (!obj.insights.every(isInsight)) return false;
  }
  if (obj.tables != null) {
    if (!Array.isArray(obj.tables)) return false;
    if (!obj.tables.every(isClinicalTable)) return false;
  }
  if (obj.visualizations != null) {
    if (!Array.isArray(obj.visualizations)) return false;
    if (!obj.visualizations.every(isClinicalVisualization)) return false;
  }
  if (obj.follow_ups != null) {
    if (!Array.isArray(obj.follow_ups)) return false;
    if (!obj.follow_ups.every(isFollowUp)) return false;
  }
  return true;
}

/** Type guard for ChatResponse */
export function isChatResponse(obj: unknown): obj is ChatResponse {
  if (!isObject(obj)) return false;
  return (
    typeof obj.conversation_id === "string" &&
    isAgentResponse(obj.response)
  );
}

/**
 * Patient list item from API response.
 * Represents a single patient in the paginated response.
 */
export interface PatientListItem {
  id: string;
  fhir_id: string;
  data: FhirPatient;
}

/**
 * Paginated response for patient list.
 */
export interface PaginatedPatientList {
  items: PatientListItem[];
  total: number;
  skip: number;
  limit: number;
}

/**
 * Type guard to check if an object is a valid PatientListItem.
 */
export function isPatientListItem(obj: unknown): obj is PatientListItem {
  if (typeof obj !== "object" || obj === null) return false;
  const item = obj as Record<string, unknown>;
  return (
    typeof item.id === "string" &&
    typeof item.fhir_id === "string" &&
    typeof item.data === "object" &&
    item.data !== null
  );
}

/**
 * Type guard to check if an object is a valid PaginatedPatientList.
 */
export function isPaginatedPatientList(
  obj: unknown
): obj is PaginatedPatientList {
  if (typeof obj !== "object" || obj === null) return false;
  const data = obj as Record<string, unknown>;
  return (
    Array.isArray(data.items) &&
    typeof data.total === "number" &&
    typeof data.skip === "number" &&
    typeof data.limit === "number"
  );
}

/**
 * Parse and validate patient list from API response.
 * Handles both paginated response (new) and legacy array response (deprecated).
 */
export function parsePatientList(data: unknown): PatientListItem[] {
  // Handle paginated response (new format)
  if (isPaginatedPatientList(data)) {
    return data.items.filter(isPatientListItem);
  }
  // Handle legacy array response (deprecated)
  if (Array.isArray(data)) {
    return data.filter(isPatientListItem);
  }
  return [];
}

// =============================================================================
// Session Types (mirrors backend/app/schemas/session.py)
// =============================================================================

/** Session status values */
export const SESSION_STATUSES = ["active", "completed"] as const;
export type SessionStatus = (typeof SESSION_STATUSES)[number];

/** Message stored in a session */
export interface SessionMessage {
  role: MessageRole;
  content: string;
}

/** Session response from API */
export interface SessionResponse {
  id: string;
  status: SessionStatus;
  patient_id: string;
  parent_session_id: string | null;
  name: string | null;
  summary: string | null;
  messages: SessionMessage[];
  started_at: string;
  last_active_at: string;
  completed_at: string | null;
}

/** Paginated list of sessions */
export interface SessionListResponse {
  items: SessionResponse[];
  total: number;
  skip: number;
  limit: number;
}

/** Type guard for SessionResponse */
export function isSessionResponse(obj: unknown): obj is SessionResponse {
  if (!isObject(obj)) return false;
  if (typeof obj.id !== "string") return false;
  if (!SESSION_STATUSES.includes(obj.status as SessionStatus)) return false;
  if (typeof obj.patient_id !== "string") return false;
  if (typeof obj.started_at !== "string") return false;
  if (typeof obj.last_active_at !== "string") return false;
  return true;
}

/** Type guard for SessionListResponse */
export function isSessionListResponse(obj: unknown): obj is SessionListResponse {
  if (!isObject(obj)) return false;
  if (!Array.isArray(obj.items)) return false;
  if (typeof obj.total !== "number") return false;
  if (typeof obj.skip !== "number") return false;
  if (typeof obj.limit !== "number") return false;
  return true;
}
