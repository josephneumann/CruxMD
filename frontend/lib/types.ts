/**
 * Application-level TypeScript types for CruxMD frontend.
 *
 * API types are auto-generated by @hey-api/openapi-ts in lib/generated/.
 * This file contains app-specific types and chat/agent types that mirror
 * the backend Pydantic schemas.
 */

import type { FhirPatient } from "./utils";

// Re-export generated types for convenience
export type { BundleLoadResponse } from "./generated";

// =============================================================================
// Chat API Types (mirrors backend/app/routes/chat.py)
// =============================================================================

/** Input validation constants matching backend limits */
export const MAX_MESSAGE_LENGTH = 10000;
export const MAX_CONVERSATION_HISTORY = 50;

/** Valid message roles - source of truth for type and validation */
export const MESSAGE_ROLES = ["user", "assistant"] as const;
export type MessageRole = (typeof MESSAGE_ROLES)[number];

/** A single message in conversation history */
export interface ChatMessage {
  role: MessageRole;
  content: string;
}

/** Available model options for the chat */
export const MODEL_OPTIONS = [
  { id: "gpt-4o", label: "GPT-4o", description: "Fast and capable" },
  { id: "gpt-4o-mini", label: "GPT-4o mini", description: "Fastest responses" },
  { id: "gpt-5.2", label: "GPT-5.2", description: "Deep reasoning" },
] as const;

export type ModelId = (typeof MODEL_OPTIONS)[number]["id"];

export const DEFAULT_MODEL: ModelId = "gpt-4o";

/** Request body for POST /api/chat */
export interface ChatRequest {
  patient_id: string;
  message: string;
  conversation_id?: string;
  conversation_history?: ChatMessage[];
  model?: string;
}

/** Response wrapper from POST /api/chat */
export interface ChatResponse {
  conversation_id: string;
  response: AgentResponse;
}

// =============================================================================
// Agent Response Types (mirrors backend/app/schemas/agent.py)
// =============================================================================

/** Query specification for resolving data at runtime */
export interface DataQuery {
  resource_types?: string[];
  filters?: string;
  time_range?: string;
  limit?: number;
}

/** Valid insight types - source of truth for type and validation */
export const INSIGHT_TYPES = ["info", "warning", "critical", "positive"] as const;
export type InsightType = (typeof INSIGHT_TYPES)[number];

/** Clinical insight highlighted for the user */
export interface Insight {
  type: InsightType;
  title: string;
  content: string;
  citations?: string[];
}

/** Valid column formats - source of truth for type and validation */
export const COLUMN_FORMATS = ["text", "date", "number", "badge"] as const;
export type ColumnFormat = (typeof COLUMN_FORMATS)[number];

/** Column definition for a data table */
export interface TableColumn {
  key: string;
  header: string;
  format?: ColumnFormat;
}

/** Valid visualization types - source of truth for type and validation */
export const VISUALIZATION_TYPES = ["line_chart", "bar_chart", "timeline", "vitals_grid"] as const;
export type VisualizationType = (typeof VISUALIZATION_TYPES)[number];

/** Visualization specification for charts and graphs */
export interface Visualization {
  type: VisualizationType;
  title: string;
  description?: string;
  data_query: DataQuery;
  config?: string;
}

/** Table specification for displaying structured data */
export interface DataTable {
  title: string;
  columns: TableColumn[];
  data_query: DataQuery;
}

/** Valid action types - source of truth for type and validation */
export const ACTION_TYPES = ["order", "refer", "document", "alert", "link"] as const;
export type ActionType = (typeof ACTION_TYPES)[number];

/** Suggested action for the user to take */
export interface Action {
  label: string;
  type: ActionType;
  description?: string;
  payload?: string;
}

/** Suggested follow-up question for emergent navigation */
export interface FollowUp {
  question: string;
  intent?: string;
}

/** Structured response from the clinical reasoning agent */
export interface AgentResponse {
  thinking?: string;
  narrative: string;
  insights?: Insight[];
  visualizations?: Visualization[];
  tables?: DataTable[];
  actions?: Action[];
  follow_ups?: FollowUp[];
}

// =============================================================================
// Type Guards for Runtime Validation
// =============================================================================

/** Helper to check if value is a non-null object */
function isObject(obj: unknown): obj is Record<string, unknown> {
  return typeof obj === "object" && obj !== null;
}

/** Type guard for ChatMessage */
export function isChatMessage(obj: unknown): obj is ChatMessage {
  if (!isObject(obj)) return false;
  return (
    MESSAGE_ROLES.includes(obj.role as MessageRole) &&
    typeof obj.content === "string"
  );
}

/** Type guard for DataQuery */
export function isDataQuery(obj: unknown): obj is DataQuery {
  if (!isObject(obj)) return false;
  // All fields are optional, but validate types if present
  if (obj.resource_types != null) {
    if (!Array.isArray(obj.resource_types)) return false;
    if (!obj.resource_types.every((t) => typeof t === "string")) return false;
  }
  if (obj.filters != null && typeof obj.filters !== "string") return false;
  if (obj.time_range != null && typeof obj.time_range !== "string") return false;
  if (obj.limit != null && typeof obj.limit !== "number") return false;
  return true;
}

/** Type guard for Insight */
export function isInsight(obj: unknown): obj is Insight {
  if (!isObject(obj)) return false;
  if (!INSIGHT_TYPES.includes(obj.type as InsightType)) return false;
  if (typeof obj.title !== "string") return false;
  if (typeof obj.content !== "string") return false;
  // Validate citations array if present
  if (obj.citations != null) {
    if (!Array.isArray(obj.citations)) return false;
    if (!obj.citations.every((c) => typeof c === "string")) return false;
  }
  return true;
}

/** Type guard for TableColumn */
export function isTableColumn(obj: unknown): obj is TableColumn {
  if (!isObject(obj)) return false;
  if (typeof obj.key !== "string") return false;
  if (typeof obj.header !== "string") return false;
  if (obj.format != null && !COLUMN_FORMATS.includes(obj.format as ColumnFormat)) return false;
  return true;
}

/** Type guard for Visualization */
export function isVisualization(obj: unknown): obj is Visualization {
  if (!isObject(obj)) return false;
  if (!VISUALIZATION_TYPES.includes(obj.type as VisualizationType)) return false;
  if (typeof obj.title !== "string") return false;
  if (obj.description != null && typeof obj.description !== "string") return false;
  if (!isDataQuery(obj.data_query)) return false;
  if (obj.config != null && typeof obj.config !== "string") return false;
  return true;
}

/** Type guard for DataTable */
export function isDataTable(obj: unknown): obj is DataTable {
  if (!isObject(obj)) return false;
  if (typeof obj.title !== "string") return false;
  if (!Array.isArray(obj.columns)) return false;
  if (!obj.columns.every(isTableColumn)) return false;
  if (!isDataQuery(obj.data_query)) return false;
  return true;
}

/** Type guard for Action */
export function isAction(obj: unknown): obj is Action {
  if (!isObject(obj)) return false;
  if (typeof obj.label !== "string") return false;
  if (!ACTION_TYPES.includes(obj.type as ActionType)) return false;
  if (obj.description != null && typeof obj.description !== "string") return false;
  if (obj.payload != null && typeof obj.payload !== "string") return false;
  return true;
}

/** Type guard for FollowUp */
export function isFollowUp(obj: unknown): obj is FollowUp {
  if (!isObject(obj)) return false;
  if (typeof obj.question !== "string") return false;
  if (obj.intent != null && typeof obj.intent !== "string") return false;
  return true;
}

/** Type guard for AgentResponse with deep validation */
export function isAgentResponse(obj: unknown): obj is AgentResponse {
  if (!isObject(obj)) return false;
  // narrative is the only required field
  if (typeof obj.narrative !== "string") return false;
  if (obj.thinking != null && typeof obj.thinking !== "string") return false;
  // Validate optional arrays with element-level validation
  // Backend sends null for absent optional fields (Python None â†’ JSON null)
  if (obj.insights != null) {
    if (!Array.isArray(obj.insights)) return false;
    if (!obj.insights.every(isInsight)) return false;
  }
  if (obj.visualizations != null) {
    if (!Array.isArray(obj.visualizations)) return false;
    if (!obj.visualizations.every(isVisualization)) return false;
  }
  if (obj.tables != null) {
    if (!Array.isArray(obj.tables)) return false;
    if (!obj.tables.every(isDataTable)) return false;
  }
  if (obj.actions != null) {
    if (!Array.isArray(obj.actions)) return false;
    if (!obj.actions.every(isAction)) return false;
  }
  if (obj.follow_ups != null) {
    if (!Array.isArray(obj.follow_ups)) return false;
    if (!obj.follow_ups.every(isFollowUp)) return false;
  }
  return true;
}

/** Type guard for ChatResponse */
export function isChatResponse(obj: unknown): obj is ChatResponse {
  if (!isObject(obj)) return false;
  return (
    typeof obj.conversation_id === "string" &&
    isAgentResponse(obj.response)
  );
}

/**
 * Patient list item from API response.
 * Represents a single patient in the paginated response.
 */
export interface PatientListItem {
  id: string;
  fhir_id: string;
  data: FhirPatient;
}

/**
 * Paginated response for patient list.
 */
export interface PaginatedPatientList {
  items: PatientListItem[];
  total: number;
  skip: number;
  limit: number;
}

/**
 * Type guard to check if an object is a valid PatientListItem.
 */
export function isPatientListItem(obj: unknown): obj is PatientListItem {
  if (typeof obj !== "object" || obj === null) return false;
  const item = obj as Record<string, unknown>;
  return (
    typeof item.id === "string" &&
    typeof item.fhir_id === "string" &&
    typeof item.data === "object" &&
    item.data !== null
  );
}

/**
 * Type guard to check if an object is a valid PaginatedPatientList.
 */
export function isPaginatedPatientList(
  obj: unknown
): obj is PaginatedPatientList {
  if (typeof obj !== "object" || obj === null) return false;
  const data = obj as Record<string, unknown>;
  return (
    Array.isArray(data.items) &&
    typeof data.total === "number" &&
    typeof data.skip === "number" &&
    typeof data.limit === "number"
  );
}

/**
 * Parse and validate patient list from API response.
 * Handles both paginated response (new) and legacy array response (deprecated).
 */
export function parsePatientList(data: unknown): PatientListItem[] {
  // Handle paginated response (new format)
  if (isPaginatedPatientList(data)) {
    return data.items.filter(isPatientListItem);
  }
  // Handle legacy array response (deprecated)
  if (Array.isArray(data)) {
    return data.filter(isPatientListItem);
  }
  return [];
}
